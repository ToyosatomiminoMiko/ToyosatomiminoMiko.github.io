<!DOCTYPE html>
<html lang="zh">
<!--本程序由DeepSeek生成-->

<head>
    <meta charset="utf-8">
    <title>OLED_Canvas</title>
    <link rel="stylesheet" type="text/css" href="./main.css">
    <script type="text/javascript" src="./main.js"></script>
</head>

<body>
    <!-- 状态指示区 -->
    <div id="coordsDisplay" class="coords-display">coordinate:(X:-,Y:-)</div>
    <br>
    <!-- 主画布 -->
    <canvas id="pixelCanvas"></canvas>
    <div id="pixelIndicator" class="pixel-indicator"></div>
    <br>
    <!-- 工具控制区 -->
    <div class="tools">
        <button onclick="clearCanvas()">清除画板</button>
        <select id="toolSelect" onchange="changeTool(this.value)">
            <option value="free">绘制</option>
            <option value="line">直线</option>
            <option value="erase">擦除</option>
        </select>
        <button onclick="exportEmbedded()">导出数据</button>
    </div>
    <br>
    <!-- 数据输入输出容器 -->
    <div>
        <!--导出数据区-->
        <div class="area-data">
            <textarea id="exportOutput" class="textarea-data"></textarea>
            <br><button onclick="copyExportedData()" id="output-button">复制到剪贴板</button>
        </div>
        <!--导入数据区-->
        <div class="area-data">
            <textarea id="importData" class="textarea-data" placeholder="粘贴C数组数据:
                const uint8_t bitmap[1024] = {0x00, 0x01, ...};"></textarea>
            <br><button onclick="importEmbeddedData()">导入数据</button>
        </div>
    </div>

    <script>
        // ======================
        // 画布初始化
        // ======================
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const indicator = document.getElementById('pixelIndicator');
        // 设置物理像素尺寸(实际分辨率)
        canvas.width = 128;  // Embedded 的典型宽度
        canvas.height = 64;  // Embedded 的典型高度
        // 初始化白色画布
        let imageData = ctx.createImageData(canvas.width, canvas.height);
        // 填充白色背景(RGBA格式)
        for (let i = 0; i < imageData.data.length; i += 4) {
            imageData.data[i] = 255;     // R
            imageData.data[i + 1] = 255; // G
            imageData.data[i + 2] = 255; // B
            imageData.data[i + 3] = 255; // A(完全不透明)
        }
        ctx.putImageData(imageData, 0, 0);
        // 直线预览颜色配置
        const PREVIEW_COLOR = '#FF0000'; // 红色预览
        const PREVIEW_OPACITY = 0.6;     // 60%透明度
        // 坐标转换系统
        let canvasRect = canvas.getBoundingClientRect();
        // 状态指示系统
        const coordsDisplay = document.getElementById('coordsDisplay');
        // 绘图工具设置
        let currentTool = 'free';
        let startPos = null;
        let lastPos = null;
        // 存储预览前的画布状态
        let previewImageData = null;
        // 窗口事件监听
        let resizeTimer;
    </script>
</body>
<script>
    // ======================
    // 鼠标事件监听
    // ======================
    // 鼠标进入事件
    canvas.addEventListener('mouseenter', updateCanvasRect);
    // 鼠标退出事件:重置坐标指示
    canvas.addEventListener('mouseleave', () => {
        coordsDisplay.textContent = 'coordinate:(X:-,Y:-)';
    });
    // 鼠标退出事件:隐藏画笔
    canvas.addEventListener('mouseleave', hideIndicator);
    // 鼠标移动事件
    canvas.addEventListener('mousemove', function (e) {
        const pos = getPixelPosition(e);
        updateCoordsDisplay(pos);
        updateIndicator(pos);
        const isBlack = currentTool !== 'erase' && (e.buttons & 1);
        // 直线预览模式
        if (currentTool === 'line' && startPos) {
            previewLine(pos.x, pos.y, e.buttons === 1);
            return; // 阻断自由绘制逻辑
        }
        // 自由绘制模式(仅在非直线工具时生效)
        if (currentTool !== 'line' && (e.buttons & 3)) {
            const isBlack = e.buttons & 1;
            if (lastPos) {
                drawLine(lastPos.x, lastPos.y, pos.x, pos.y, isBlack);
            } else {
                setPixel(pos.x, pos.y, isBlack);
            }
            ctx.putImageData(imageData, 0, 0);
            lastPos = pos;
        }

        // 新增边界检查
        if (!startPos) return;
        // 限制预览范围
        const boundedX = Math.max(0, Math.min(canvas.width - 1, pos.x));
        const boundedY = Math.max(0, Math.min(canvas.height - 1, pos.y));
        previewLine(boundedX, boundedY, e.buttons === 1);
    });
    // 鼠标按下事件
    canvas.addEventListener('mousedown', function (e) {
        const pos = getPixelPosition(e);
        const isBlack = currentTool !== 'erase' && e.button === 0; // 橡皮擦忽略右键

        if (currentTool === 'line') {
            if (!startPos) {
                // 记录起点并保存当前画布状态
                startPos = pos;
                previewImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            } else {
                // 正式绘制直线
                drawLine(startPos.x, startPos.y, pos.x, pos.y, isBlack);
                ctx.putImageData(imageData, 0, 0);
                startPos = null;
            }
        } else {
            // 自由绘制模式
            setPixel(pos.x, pos.y, isBlack);
            ctx.putImageData(imageData, 0, 0);
            lastPos = pos;
        }
    });
    // ======================
    // 键盘事件监听
    // ======================
    // 按下`ESC`终止直线绘制
    document.addEventListener('keydown', function (e) {
        if (e.key === 'Escape' && currentTool === 'line' && startPos) {
            // 恢复预览前状态
            ctx.putImageData(previewImageData, 0, 0);
            // 重置绘制状态
            startPos = null;
            previewImageData = null;
        }
    });
    // ======================
    // 窗口事件监听
    // ======================
    window.addEventListener('scroll', updateCanvasRect, true);
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(updateCanvasRect, 100);
    });
</script>

</html>
